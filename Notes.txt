Software engineering
    Developers write code in high level languages
    This code is compiled into machine code - a sequence of bytes that the cpu can interpret
    Disassembly - process of converting byte sequesces into assembly instructions
    As reverse engineers, byte sequences will be our starting point

Compilation
    4 steps
        Preprocessing
        Compilation
        Assembly
        Linking
    After these 4 steps are done, an executable is produced

    Preprocessing
        Passes over source code and performs:
            Comment removal
            Macro expansion
            Include Expansion
            Conditional Compilation

    Compilation - converts the output of preprocessor into assembly instructions

    Assembly
        Assemblers conver the assembly code into binary opcodes
        The assembler will produce an object file
            Object files contain machine code
            This file will contain fields to be filled by the linker

    Linking
        More information is needed before the object code can be executed
             Entry point, starting instruction needs to be specified
        Used to define memory regions on embedded platforms
             Done through linked scripts
        Result of linking is the final executable program

Output Formats
    PE (Windows .exe files)
    ELF (Linux)
    Mach-O (OSX)
    COFF/ECOFF

    These output files are starting point for reverse engineers

Elf Files
    ELF - Executable Linking Format
    Contains information about OS, endianness, memory, etc
    ELF files have 3 components
        ELF Header
        Sections
        Segments
    This metadata is very valuable when reverse engineering
    A few tools to analyze ELF files
        dumpelf
        readelf
        objdump
        elfutils
    Elf file will contain machine code that can be converted back into assembly, which can then be converted into the original high level code
        This process is called disassembly

Computer Architecture 101
    When a programming is running
        1. An instruction is read into memory
        2. The instruction is processed by the Arithmetic Logic Unit
        3. The result of the operation is stored into registers or memory
    Basic components
        Registers - small storage areas used by the processor
            x86_64 assembly uses 16 64 bit general purpose registers
            Special purpose registers
                RIP - Instruction pointer
                    Points to the next instruction to be executed
                    64 bits in length
                RFLAGS - Stores flags used for processor flow control
                FPR0-FPR7 - Floating point status and control registers
                RBP/RSP = Stack manipulation and usage

        Instructions - Define the operations being performed by the CPU
            Can have multiple operands, which define arguments for specific operation
            Basic instructions for x86_64
                mov rax, rbx
                    Moves value from RBX to RAX
                mov rax, [rcx]
                    Moves the value pointed to by RCX into RAX
                add rax, rbx
                    Adds the two values together, storing the result in the first argument
                sub rax, rbx
                    Subtracts rbx from rax, stores result in first argument
                and rax, rax
                    Performs the binary operation AND on the two operands, storing the result in the first
                    Same syntax used on xor and or
                jmp <address>
                    Used to change what code is being executed
                    Modifies value in EIP
                    Ex. jmp 0x1000300
                        Set EIP to 0x1000300 adn execute the instructions there
                    Other jmp variants
                        jnz - jump if not zero
                        jz - jump if zero
                call <address>
                    Used to implement function calls
                    Ex. call 0x18000000
                    Pushes the value of rbp and rip into stack before jumping
                cmp
                    Performs a comparison operation by subtracting the operands
                    No storage is performed, instead based on the result, fields in RFLAGS are set
                    Ex. cmp rax, #5

        Addressing Modes
            Instructions can access registers and memory in various modes
            Immediate - the value is stored in the instruction
                Ex. add rax, 14
            Register to register
                Ex. xor rax,rax
            Indirect access
                Ex. add rax, [rbx]

        Stack - Region of contiguous memory
            POP - reads from stack
                pop rbx
                    Loads the value pointed by rsp into rbx, and decreases rsp by 8
            PUSH - writes to stack
                push rax
                    Increases the value pointed to by rsp by 8, and stores rax there
            Elements are removed in the reverse order that they are added
            Grows from high memory address to low memory address
            RSP points to top of stack
            RBP contains base pointer
        Heap
    x86_64 Architecture
        Created by AMD in 2000

Ghidra
    Provides a disassembler and decompiler
    Disassembler - go from raw bytes to assembly
    Decompiler - go from assembly to c code
    Ghidra groups binaries into projects
    Programs and binaries can be imported into a project
    File > New Project > Non-Shared Project
