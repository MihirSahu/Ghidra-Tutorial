Class 1
--------
Software engineering
    Developers write code in high level languages
    This code is compiled into machine code - a sequence of bytes that the cpu can interpret
    Disassembly - process of converting byte sequesces into assembly instructions
    As reverse engineers, byte sequences will be our starting point

Compilation
    4 steps
        Preprocessing
        Compilation
        Assembly
        Linking
    After these 4 steps are done, an executable is produced

    Preprocessing
        Passes over source code and performs:
            Comment removal
            Macro expansion
            Include Expansion
            Conditional Compilation

    Compilation - converts the output of preprocessor into assembly instructions

    Assembly
        Assemblers conver the assembly code into binary opcodes
        The assembler will produce an object file
            Object files contain machine code
            This file will contain fields to be filled by the linker

    Linking
        More information is needed before the object code can be executed
             Entry point, starting instruction needs to be specified
        Used to define memory regions on embedded platforms
             Done through linked scripts
        Result of linking is the final executable program

Output Formats
    PE (Windows .exe files)
    ELF (Linux)
    Mach-O (OSX)
    COFF/ECOFF

    These output files are starting point for reverse engineers

Elf Files
    ELF - Executable Linking Format
    Contains information about OS, endianness, memory, etc
    ELF files have 3 components
        ELF Header
        Sections
        Segments
    This metadata is very valuable when reverse engineering
    A few tools to analyze ELF files
        dumpelf
        readelf
        objdump
        elfutils
    Elf file will contain machine code that can be converted back into assembly, which can then be converted into the original high level code
        This process is called disassembly

Computer Architecture 101
    When a program is running
        1. An instruction is read into memory
        2. The instruction is processed by the Arithmetic Logic Unit
        3. The result of the operation is stored into registers or memory
    Basic components
        Registers - small storage areas used by the processor
            x86_64 assembly uses 16 64 bit general purpose registers
            x64 registers start with R (register), x86 start with E (extended)
            Special purpose registers
                RIP - Instruction pointer
                    Points to the next instruction to be executed
                    64 bits in length
                RFLAGS - Stores flags used for processor flow control
                FPR0-FPR7 - Floating point status and control registers
                RBP/RSP = Stack manipulation and usage

        Instructions - Define the operations being performed by the CPU
            Can have multiple operands, which define arguments for specific operation
            Basic instructions for x86_64
                mov rax, rbx
                    Moves value from RBX to RAX
                mov rax, [rcx]
                    Moves the value pointed to by RCX into RAX
                add rax, rbx
                    Adds the two values together, storing the result in the first argument
                sub rax, rbx
                    Subtracts rbx from rax, stores result in first argument
                and rax, rax
                    Performs the binary operation AND on the two operands, storing the result in the first
                    Same syntax used on xor and or
                jmp <address>
                    Used to change what code is being executed
                    Modifies value in RIP
                    Ex. jmp 0x1000300
                        Set EIP to 0x1000300 adn execute the instructions there
                    Other jmp variants
                        je - jump if equal/zero
                        jne - jump if not equal
                        jnz - jump if not zero
                        jz - jump if zero
                        jl - jump if less
                        jg - jump if greater
                call <address>
                    Used to implement function calls
                    Ex. call 0x18000000
                    Pushes the value of rbp and rip into stack before jumping
                cmp
                    Performs a comparison operation by subtracting the operands
                    No storage is performed, instead based on the result, fields in RFLAGS are set
                    Ex. cmp rax, #5

        Addressing Modes
            Instructions can access registers and memory in various modes
            Immediate - the value is stored in the instruction
                Ex. add rax, 14
            Register to register
                Ex. xor rax,rax
            Indirect access
                Ex. add rax, [rbx]

        Stack - Region of contiguous memory
            POP - reads from stack
                pop rbx
                    Loads the value pointed by rsp into rbx, and decreases rsp by 8
            PUSH - writes to stack
                push rax
                    Increases the value pointed to by rsp by 8, and stores rax there
            Elements are removed in the reverse order that they are added
            Grows from high memory address to low memory address
            RSP points to top of stack
            RBP contains base pointer
        Heap
    x86_64 Architecture
        Created by AMD in 2000

    C program assembly have common code in the first few lines that help set up the stack and save argc and argv
        Ex.
            push rbp    # Pushes base register value onto stack
            mov rbp, rsp    # Moves top stack pointer register value into bottom stack pointer register value
            mov DWORD PTR [rbp-0x14], edi     # Moves argc into stack at location rbp-0x14
            mov DWORD PTR [rbp-0x20], rsi     # Moves argv into stack at location rbp-0x20

Ghidra
    Provides a disassembler and decompiler
    Disassembler - go from raw bytes to assembly
    Decompiler - go from assembly to c code
    Ghidra groups binaries into projects
    Programs and binaries can be imported into a project
    File > New Project > Non-Shared Project

    Xrefs show what the line is referenced by

    Assembly code is shown in the Listing view and C code is shown in the Decompiler view


Class 2
--------
    There is additional code outside the main functions that are used to launch the binary
    Program startup and behavior is defined by the System V ABI (application binary interface)
        Main arguments are determined by ABI
    Within the ELF header there is an e_entry field that points the _start() function, which calls main

    Function signatures
        Can be edited in ghidra
            Argument count
            Argument types
            Return values
        Fixing the function signature can greatly improve decompiler output
        Right click on function name -> edit function signature

    The c standard defines the arguments passed to the main function
        int argc = argument count
        char **argv = argument vector
        These can be applied to function to make it more readable
            Is applied to assembly view too

    Imports and Exports
        Defined by ELF header
        Can be viewed from the symbol tree
            Imports - libraries that are utilized by your target binary
            Exports - exposed information about out binary for the operating system loader
        When importing a binary, users can also specify a part for libraries that are imported
        For our challenges, main is always a good starting point
            Defined by ABI
            If you can't find main, start with _start

    Control flow
        Order in which instructions are executed
        Common statements used to manipulate control flow:
            if/else
            goto
            switch
            while
        These statements can be reconstructed by analyzing the resulting assembly code

    Graph View
        When looking at multiple branches, graph view can display multiple blocks of code
        Can be useful when determining flow control
        Can be entered through
            Highlighting a function name
            Window -> Function Graph

    Switch Cases
        Allow a variable to be compared against a list of values
            Each value being compared against is a case
        Expression for the case must have the same data type as the variable in the switch
        The switch statement terminates on a break statement

    Converting Data
        In the listing view, data types can be converted
            Hex, decimal, char, etc.
        Right click an immediate value and select "Convert"
            Multiple representations can be applied
        This can be used to make the decompiler output more readable

    Loops
        Loops allow repeated execution of a block of code
            Statements in the loop are executed sequentially
        Loops can be implemented in assembly in multiple ways
            CMP -> JMP
            LOOP
            REP
        Usually operate under conditional code

    Highlighting/Slicing
        When viewing the assembly listing or decompiler view, items can be hightlighted
            Useful for tracking register usage in larger functions
            Middle click on a variable to highlight
                Right click for more highlight options
        Slicing can be applied in the decompiler window
            Will display usage of the selected variable
        Ghidra will attempt to sync highlights between disassembly/decompiler views

    Variables
        When a variable is declared, it is declared withing a particular scope
            The scope defines how accessible a variable is
            We will defind two types of scopes for this course: local and global
        Local variables are stored in the stack
        Global variables are stored in the .data section of the ELF file

    Labelling/Renaming
        Variables and offsets can be labelled in ghidra
            Useful for labelling memory regions
            Makes pseudo code more understandable
        Right click on variable > rename variable
        Ghidra will sync the variable names between listing view and decompiler view

    Functions
        Functions are called using the call instruction
            Call pushes the return address to the stack when called
        The first 6 function parameters are passed in through registers
            RDI, RSI, RDX, RCX, R8, R9
            After this parameters are passed through the stack
            Large parameters/structures passed by value are passed through the stack
        ret is used to return from a function
            The return address is popped off the stack and placed into RIP
        Functions can be thought of as three components
            Prologue - reserves space for variables on the stack
            Body
            Epilogue - cleans up the stack frame and returns it to it's original state

    Calling Conventions
        Define how function calls are implemented
            How arguments are passed
            How return values are passed back from functions
            Stack management and register cleanup
        GNU/Linux uses System V AMD64 ABI
        Calling convention defined the epilogue/prologue for functions

    Functions in Ghidra
        Ghidra can perform function comparisons
            Useful for doing side by side comparisons of similar functions
        Ghidra will display the two functions side by side
        Highlight two functions, right click > compare selected functions

    Heap Memory
        The heap is used for dynamic memory allocations
            Used when the size of a variable can be varied
            malloc/calloc - used to allocate
        Heap memory is not managed automatically
            Devs must manage it manually
            free(var) used to free memory
            Failure to do so results in memory leaks
        Heap variables can be accessed globally

    Stack vs Heap
        Stack memory
            No need to deallocate
            Local variables only
            Limited by stack size (OS dependent)
            Statically sized variables
        Heap memory
            Variables can be accessed globally
            No limit on size
            Must be managed by user

    Array Accesses
        Array accesses often utilize the LEA instruction
        LEA = Load Effective Address
            Loads the address of the memory calculation into the register
            Does not dereference the value as MOV would
        LEA EAX, [EAX + EBX + 1234567]
            Stores the value of EAX + EBX + 1234567 into EAX
            Does not dereference!

    * The decompiler view is a great resource, but it's not always correct. Use the Listing view with the assembly code if the decompiler with c code is unclear


Class 3
--------
    A few RE tools other than ghidra
        Radare/r2 - disassembler
        IDA Pro - disassembler/decompiler
            Large amount of plugins and community tools
            Handles c++ binaries well
            PDB parsing works well
            In develpment for over a decade, was industry standard standard
        Objdump - disassembler
    All these tools have pros and cons, many use a combination of these tools
    Factors to consider when choosing RE tools
        Usability
        Architecture support
        File format support
        Extendibility
        Price
    Experiment with as many tools as possible

    Structures
        User defined data type allowing for combining various data types
        Composite data type defining a grouped list of variables under one name in a block of memory
        Directly reference a contiguous block of memory
            Padding bytes may be added for alignment purposes
        Elements in structures need to be byte aligned
            Most compilers do this, but is compiler dependent
            Fields that are not byte aligned with the CPU will be padded
                This is to stop unaligned accesses from occurring
                Used for compiler optimizations as well
            Ex. a byte sized element will occupy 4 bytes of memory but only use 1

    Ghidra Structures
        Structures can be added to ghidra in multiple ways
            Import header files
                File > Parse c source
            Manual creation in struct creator
                Can be done from the data types manager

    Non Ascii from Command Line
        So far the challenges for the course have worked on ASCII inputs/outputs
        Python can be used to provide non-ASCII input from the command line
        To provide hex values 0x210010
            Ex. ./exercise `python -c 'print "\x21\x00\x10"'`

    Pointers
        Pointer is a variable whose value is the address of another variable
            Direct address of a memory location
        Pointers provide an indirect method of accessing variables
        Pointers are always the same size, despite the size of the data that they point to
            This will be compiler/architecture dependent
